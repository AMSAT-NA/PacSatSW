/*
 * TMS570Hardware.c
 *
 *  Created on: Jun 1, 2019
 *      Author: bfisher
 */
#include <pacsat.h>

#include "downlink.h"
#include "TMS570Hardware.h"
#include "reg_system.h"
#include "rti.h"
#include "SystemServiceEntry.h"
#include "errors.h"
#include "esm.h"
#include "reg_tcram.h"
#include "reg_flash.h"

// Bits in RAMERRSTATUS register
#define SERR 0x01
#define ADDR_DEC_FAIL 0x04
#define ADDR_COMP_LOGIC_FAIL 0x10
#define DERR 0x20 /*Double bit error*/
#define RADDR_PAR_FAIL 0x100 /*Read address parity failure*/
#define WADDR_PAR_FAIL 0x200 /*Write address parity failure*/

extern rt1Errors_t localErrorCollection;
/*
 * This module contains routines that talk directly to the TMS570 but which are not
 * generated by or directly related to HalCoGen.
 */
void ProcessorReset(void){
    SWIRaisePrivilege();
    systemREG1->SYSECR = 0x8000;  //This should cause a reset

}

/* Supervisor mode system service*/
void swiWDSetTimer(void){
    dwdSetPreload(0xffff);
}

void swiWDStart(void){
    dwdCounterEnable();
}

void swiBusSwitch(void){
    esmREG->EKR = 0xa;  // Set the error bit
    esmActivateNormalOperation(); // Then unset it
}

void esmGroup1Notification(uint32_t channel){
    /*
     * The error signalling module will call here if we get some group1 errors.  The channel
     * specifies which particular error we have gotten.
     *
     * A couple points here:  We want to log most errors, but some require a reboot or even a power
     * cycle.  We will want to ensure that the log is sent to the other processor before we reboot.
     * Although a reboot will normally force nError, that is a switch to the other processor, in these
     * cases we want to switch immediately and then try to send the data over CAN2.
     */
    static int ramErrNumber = 0;
    switch(channel){
    case FlashEccCorrectable:{
        /*
         * We keep two data cells for each processor to hold an address
         * with a corrected error.  The data cell number is kept in errNumber
         * and will have the value of 0 and 2;  the processor number is in procNum
         * with a value of 0 or 1.  The sum of the two gives us an offset of 0 to 3
         *
         * todo: Swap processors when necessary and set up a timed reboot and force the
         * CAN message to be sent to the other processor when required.
         *
         */
        static int errNumber = 0;
        uint32_t *errorLoc = &localErrorCollection.ROMCorAddr1;
        errorLoc[errNumber] = (uint32_t)flashWREG->FCORERRADD;
        flashWREG->FEDACSTATUS &= 0xFFFFFFF9; //Clear the bits the freeze the corrected address register
        if(errNumber==0)errNumber=1;
        else errNumber = 0;
        localErrorCollection.FlashCorCnt++;
    }
    case PLL1Slip:{
        localErrorCollection.PLLSlipCnt++;
    }
    case ClockMonitorOscFail:{
        localErrorCollection.ClockMonitorFailCnt++;
    }
    case VIMRamParity:{
        localErrorCollection.VIMRamParityCnt++;
    }
    case CAN1RamParity:{
        //Drop active status, log, reset
        localErrorCollection.CAN1RamParityCnt++;
    }
    case CAN2RamParity:{
        //Drop active status, log, reset
        localErrorCollection.CAN2RamParityCnt++;
    }
    /*
     * For the even and odd backs of ECC memory, we count them separately, but we use the same pair
     * of 32-bit words to downlink the addresses.  These 32-bit words have the last two addresses that
     * have had a corrected error.
     *
     * No write-back is required since the processor does that itself.
     */
    case RAMEvenBankCorrectableECC:{
        uint32_t *errorLoc = &localErrorCollection.RAMCorAddr1;
        errorLoc[ramErrNumber] = (uint32_t)tcram2REG->RAMSERRADDR;;
        tcram2REG->RAMERRSTATUS |= SERR; //Clear the bits the freeze the corrected address register
        if(ramErrNumber==0)ramErrNumber=1;
        else ramErrNumber = 0;
        localErrorCollection.RamEvenCorCnt++;
        tcram2REG->RAMERRSTATUS |= SERR;
        break;
    }

    case RAMOddBankCorrectableECC:{
        uint32_t *errorLoc = &localErrorCollection.RAMCorAddr1;
        errorLoc[ramErrNumber] = (uint32_t)tcram1REG->RAMSERRADDR;;
        tcram1REG->RAMERRSTATUS |= SERR; //Clear the bits the freeze the corrected address register
        if(ramErrNumber==0)ramErrNumber=1;
        else ramErrNumber = 0;
        localErrorCollection.RamOddCorCnt++;
        tcram1REG->RAMERRSTATUS |= SERR;
        break;
    }
    case DCC1Error:{
        //nError, log, power cycle
        localErrorCollection.DCC1ErrorCnt++;
        break;
    }
    case N2HET2RamParity:{
        //nError,reboot
        localErrorCollection.N2HET2RamParityCnt++;
        break;
    }
    case IOMMAccvio:{
        localErrorCollection.IOMMAccvioCnt++;
        //Software bug - nERROR, log, reboot
        break;
    }
    case DCC2Error:{
        localErrorCollection.DCC1ErrorCnt++;
        //nError, log, power cycle
    }
    }
}

void esmGroup2Notification(uint32_t channel){
    /*
     * The error signalling module will call here if we get some group2 errors.  The channel
     * specifies which particular error we have gotten.
     */
    // For the moment we log all of these if possible and reboot.  We may want to power cycle, so it will
    // be hard to log.
}
volatile uint64_t readScrub;
void ScrubECCMemory(uint64_t *start,uint32_t length){
    /*
     * This just reads memory starting at 'start' and going for
     * length bytes.  If there is a correctable error, the hardware itself
     * corrects it and writes it back (so says TI).  It should also report
     * it to the error module for downlinking.
     */
    int i;
    length = length/sizeof(uint64_t);
    for(i=0;i<length;i++){
        readScrub = start[i];
    }

}
